// Generated by CoffeeScript 1.12.6
var _, abs_path, each_sub_mod, esprima, fs, get, if_assignment_statement, if_variable_declaration, internal_modules, load, matches_module, mock, parse_private_modules, path, resolve, rewire, set;

path = require("path");

resolve = require("resolve");

fs = require("fs");

rewire = require("rewire");

_ = require("lodash");

esprima = require("esprima");

mock = require("./mock");

set = function(wired, path, value) {
  return wired.__set__(path, value);
};

get = function(wired, path) {
  return wired.__get__(path);
};

if_variable_declaration = function(node, base, list) {
  if (!node || node.type !== "VariableDeclaration") {
    return;
  }
  return _.each(node.declarations, function(declare) {
    var mod_loc, statement, statement_args;
    statement = declare && declare.type === "VariableDeclarator" && declare.init;
    if (!statement) {
      return;
    }
    if (statement.callee && statement.callee.name === "require") {
      statement_args = statement["arguments"] && statement["arguments"].length > 0;
      mod_loc = statement_args ? statement["arguments"][0].value : void 0;
      return list.push({
        name: declare.id ? declare.id.name : void 0,
        path: mod_loc
      });
    }
  });
};

if_assignment_statement = function(node, base, list) {
  var exp, mod_loc, name, right_args;
  exp = node && node.type === "ExpressionStatement" && node.expression;
  if (exp.type === "AssignmentExpression" && exp.right && exp.left && exp.right.type === "CallExpression" && exp.right.callee.name === "require") {
    name = (function() {
      switch (false) {
        case exp.left.type !== "Identifier":
          return exp.left.name;
        default:
          return name = exp.left.object.name + "." + exp.left.property.name;
      }
    })();
    right_args = exp.right["arguments"] && exp.right["arguments"].length > 0;
    mod_loc = right_args ? exp.right["arguments"][0].value : void 0;
    return list.push({
      name: name,
      path: mod_loc
    });
  }
};

internal_modules = function(ast, base, list) {
  if (!list) {
    list = [];
  }
  if (!ast || !ast.body) {
    return list;
  }
  _.each(ast.body, function(node) {
    if_variable_declaration(node, base, list);
    if_assignment_statement(node, base, list);
    return internal_modules(node, base, list);
  });
  return list;
};

abs_path = function(loc, base) {
  return resolve.sync(loc, {
    basedir: base || ""
  });
};

each_sub_mod = function(file) {
  var ast, base, data, mods;
  base = path.dirname(file);
  mods = null;
  if (fs.existsSync(file)) {
    data = fs.readFileSync(file, "utf-8");
    if (data) {
      ast = esprima.parse(data);
      mods = internal_modules(ast, base);
    }
  }
  return mods || [];
};

matches_module = function(mod, base) {
  return function(compare) {
    return compare === mod.path;
  };
};

parse_private_modules = function(module_path, wired, accept) {
  return each_sub_mod(module_path).forEach(function(mod) {
    var obj;
    if (!accept.some(matches_module(mod, module_path))) {
      return;
    }
    obj = get(wired, mod.name);
    _.each(Object.keys(obj), function(key) {
      if (typeof obj[key] !== "function") {
        return;
      }
      return obj[key] = mock.stub(obj, key);
    });
    if (typeof obj === "function") {
      return set(wired, mod.name, _.extend(mock.stub(), obj));
    }
  });
};

load = function(module_path, base, accept) {
  var full_path, wired;
  if (accept == null) {
    accept = [];
  }
  full_path = abs_path(module_path, base);
  wired = rewire(full_path);
  parse_private_modules(full_path, wired, accept);
  return wired;
};

module.exports = {
  set: set,
  get: get,
  load: load
};
